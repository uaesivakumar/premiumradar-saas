# Admin Plane v1.1 — Locked Contracts

**Created:** 2025-12-31
**Status:** LOCKED (Founder Approved)
**Sprints:** S340-S346

---

## MANDATORY RULE #1: Enterprise-First (No Dual-Write)

### Hard Rules

1. **Enterprise is the source of truth immediately**
2. **Tenant is read-only compatibility only** (if unavoidable)
3. **If tenant must be written for legacy reasons:**
   - It MUST be strictly derived from enterprise_id (1:1 mapping)
   - It MUST never be referenced by new code

### API Contract

| Rule | Enforcement |
|------|-------------|
| All new Admin Plane APIs accept/return `enterprise_id` only | BLOCKED if violated |
| No new endpoint payload contains `tenant_id` | BLOCKED if violated |
| Session context exposes `enterprise_id`, never `tenant_id` to new UI pages | BLOCKED if violated |
| Legacy code that reads tenant must go through enterprise bridge | REQUIRED |

### Migration Path

If tenant must exist for legacy reasons:
```
Enterprise (source of truth)
    ↓ (derived, 1:1)
Tenant (compatibility layer, read-only)
```

New code flow:
```
API → enterprise_id → DB
         ↓
    (if legacy needs tenant)
         ↓
    tenantBridge.getOrCreateFromEnterprise(enterprise_id)
```

---

## MANDATORY RULE #2: Deterministic Evidence (No Live LLM)

### Hard Rules

1. **EvidencePack.summary is generated by deterministic rules-based narrator (template engine) in v1.1**
2. **No live LLM generation for evidence summaries**
3. **Optional LLM style rewrite (future) must be:**
   - Seeded
   - Cached
   - Stored as artifact
   - Reproducible

### Evidence Narrative Contract v1.1

```typescript
interface EvidencePack {
  // Deterministic narrator output (template-based)
  summary: string;

  // Key events in chronological order
  timeline: EventEntry[];

  // BTE-derived signals (computed, not LLM-generated)
  signals: DerivedSignal[];

  // Missed opportunities (rule-based detection)
  counterfactuals: string[];

  // Confidence based on data completeness (threshold-based)
  confidence: 'High' | 'Medium' | 'Low';

  // Narrator version for reproducibility
  narrator_version: string; // e.g., "deterministic-v1.1"
}
```

### Narrator Implementation

```typescript
// CORRECT: Deterministic narrator
function generateNarrativeSummary(events: EventEntry[], signals: DerivedSignal[]): string {
  const templates = {
    high_engagement: "User {user} showed strong engagement with {action_count} actions over {days} days.",
    low_engagement: "User {user} had minimal activity with only {action_count} actions.",
    demo_expired: "Demo expired after {days} days due to {reason}.",
    converted: "Successfully converted from demo to real on {date}.",
  };

  // Select template based on event patterns
  const pattern = detectPattern(events, signals);
  return fillTemplate(templates[pattern], extractVariables(events));
}

// WRONG: Live LLM call
function generateNarrativeSummary(events: EventEntry[]): string {
  return await llm.generate("Summarize these events: " + JSON.stringify(events));
  // NO! This is non-deterministic and non-reproducible
}
```

### Why This Matters

> "In enterprise, 'AI told me' is not evidence. Replayability matters."

- Every evidence pack must produce the same output given the same inputs
- Auditors must be able to verify evidence independently
- System must be able to explain decisions without external dependencies

---

## Resolved Context Contract

```typescript
interface ResolvedContext {
  // User identity
  user_id: string;
  role: 'SUPER_ADMIN' | 'ENTERPRISE_ADMIN' | 'ENTERPRISE_USER' | 'INDIVIDUAL_USER';

  // Organization hierarchy (enterprise-first)
  enterprise_id: string | null;
  workspace_id: string | null;

  // Vertical binding
  sub_vertical_id: string | null;
  region_code: string | null; // e.g., 'UAE', 'US' (string, not UUID - no os_regions table yet)

  // Demo state
  is_demo: boolean;
  demo_type: 'SYSTEM' | 'ENTERPRISE' | null;
}
```

### Resolution Rules

1. **Stored in DB:** User record contains all context fields
2. **Resolved on every request:** Middleware resolves context from session
3. **Logged on mutations:** Every write operation includes actor context
4. **Emitted to BTE:** Business events include full resolved context

---

## Schema Contracts (Primary Keys)

| Table | Primary Key | Naming |
|-------|-------------|--------|
| enterprises | `enterprise_id` (UUID) | Explicit naming |
| workspaces | `workspace_id` (UUID) | Explicit naming |
| users | `id` (UUID) | Standard naming |
| demo_policies | `id` (UUID) | Standard naming |
| business_events | `id` (UUID) | Standard naming |
| audit_log | `id` (UUID) | Standard naming |

**Rule:** Use explicit `*_id` naming for foreign key references to avoid ambiguity.

---

## Role Taxonomy (Locked)

### Valid Roles (Use in all new code)

- `SUPER_ADMIN`
- `ENTERPRISE_ADMIN`
- `ENTERPRISE_USER`
- `INDIVIDUAL_USER`

### Deprecated Roles (Do not use in new code)

- ~~`TENANT_ADMIN`~~ → Use `ENTERPRISE_ADMIN`
- ~~`TENANT_USER`~~ → Use `ENTERPRISE_USER`
- ~~`READ_ONLY`~~ → Remove (not a valid role)

---

## UI Naming Contract

| Current Path | Current Label | Target Label |
|--------------|---------------|--------------|
| `/superadmin/tenants` | "Tenants" | **"Enterprises"** |
| `/superadmin/users` | "Users" | "Users" (unchanged) |

**Note:** Path can stay `/tenants` temporarily, but UI label must say "Enterprises" to eliminate conceptual drift.

---

## Acceptance Tests (Locked)

1. Create Real Enterprise → Create Enterprise Admin → Create Enterprise User → verify constraints
2. Create Demo Enterprise (1 click) → verify expiry fields + policy binding
3. Convert Demo Enterprise → Real (plan/status change + audit trail)
4. Create Individual User (self serve) → choose vertical/subvertical/region → workspace created + eligibility enforced
5. Convert Individual Demo → Real
6. Evidence pack shows events + deterministic narrative (not LLM-generated)
7. UI actions exist and mutate real DB (no tenant_id in request/response)

---

## Violation Policy

Any PR that violates these contracts will be **BLOCKED** during `/integrator` and `/qa` phases.

TC must:
1. Check each new file against these contracts
2. Verify no `tenant_id` in new API payloads
3. Verify evidence generation is deterministic
4. Verify role taxonomy uses only valid roles
