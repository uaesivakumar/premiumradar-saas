# PremiumRadar Integration Verifier v2.1

**MANDATORY GATE** - Verifies Feature Wiring Contracts with RUNTIME PROOF.

**Version:** 2.1 - Contract-based verification (NO git diff)

---

## CRITICAL: CONTRACT-DRIVEN VERIFICATION

**/integrator does NOT infer wiring from git diff or grep.**

Verification is ONLY against Feature Wiring Contracts defined in `/start`.

If a feature has no contract → **FAIL**.

---

## VERIFICATION FLOW

```
/integrator
    │
    ├── Step 1: Load session state and contracts
    ├── Step 2: Validate contracts exist (FAIL if empty)
    ├── Step 3: Load environment config
    │
    ├── FOR EACH CONTRACT:
    │   ├── Phase A: UI Entrypoint Verification
    │   ├── Phase B: API Endpoint Verification
    │   ├── Phase C: Test Verification
    │   └── Phase D: Staging Runtime Verification
    │
    ├── Step 4: Generate verification report
    ├── Step 5: Update session state
    └── Step 6: PASS or FAIL
```

---

## STEP 1: Load Session State

```bash
SESSION_FILE=".claude/session/current.json"

if [ ! -f "$SESSION_FILE" ]; then
  echo "FAIL: No session state found"
  echo "Run /start first to initialize session and generate contracts"
  exit 1
fi

SESSION=$(cat "$SESSION_FILE")
```

---

## STEP 2: Validate Contracts Exist

```javascript
const session = JSON.parse(fs.readFileSync('.claude/session/current.json'));

if (!session.feature_contracts || session.feature_contracts.length === 0) {
  console.error("FAIL: No Feature Wiring Contracts defined");
  console.error("Cannot verify integration without contracts");
  console.error("/integrator requires contracts to be generated by /start");
  process.exit(1);
}

const contracts = session.feature_contracts;
console.log(`Loaded ${contracts.length} contracts for verification`);
```

---

## STEP 3: Load Environment Config

```javascript
const env = session.environment;

if (!env.staging_base_url) {
  console.error("FAIL: staging_base_url not defined in environment config");
  process.exit(1);
}

const STAGING_URL = env.staging_base_url;
const HEALTH_ENDPOINT = env.health_endpoint || '/api/health';
```

---

## PHASE A: UI Entrypoint Verification

**Proves the UI component/page exists AND renders.**

```javascript
async function verifyUIEntrypoint(contract) {
  const ui = contract.ui_entrypoint;
  const results = { exists: false, renders: null };

  // 1. Check file exists
  const filePath = ui.path;
  if (!fs.existsSync(filePath)) {
    return {
      success: false,
      error: `UI file not found: ${filePath}`
    };
  }
  results.exists = true;

  // 2. For pages/components with renders_at, verify runtime render
  if (ui.renders_at && ui.type !== 'api_only' && ui.type !== 'background') {
    const url = `${STAGING_URL}${ui.renders_at}`;
    const response = await fetch(url, {
      method: 'GET',
      redirect: 'follow'
    });

    if (response.status === 200) {
      results.renders = true;
    } else if (response.status === 401 || response.status === 403) {
      // Auth-protected pages are OK
      results.renders = true;
    } else {
      return {
        success: false,
        error: `Page does not render: ${url} returned ${response.status}`
      };
    }
  }

  return { success: true, results };
}
```

---

## PHASE B: API Endpoint Verification

**Proves each API endpoint exists AND responds correctly.**

```javascript
async function verifyAPIEndpoints(contract, STAGING_URL) {
  const endpoints = contract.api_endpoints;
  const results = [];

  for (const endpoint of endpoints) {
    const url = `${STAGING_URL}${endpoint.path}`;
    const expected = endpoint.expected_response_shape;

    try {
      const response = await fetch(url, {
        method: endpoint.method,
        headers: { 'Content-Type': 'application/json' },
        body: endpoint.method !== 'GET' && endpoint.required_request_fields
          ? JSON.stringify(Object.fromEntries(
              endpoint.required_request_fields.map(f => [f, 'test'])
            ))
          : undefined
      });

      // Check status
      if (expected.success_status && response.status !== expected.success_status) {
        // 401/403 is acceptable for auth-protected endpoints
        if (response.status !== 401 && response.status !== 403) {
          results.push({
            endpoint: `${endpoint.method} ${endpoint.path}`,
            success: false,
            error: `Expected status ${expected.success_status}, got ${response.status}`
          });
          continue;
        }
      }

      // If we got a JSON response, check required fields
      if (response.status === 200 && expected.required_fields) {
        const body = await response.json();
        const missingFields = expected.required_fields.filter(
          f => !(f in body)
        );
        if (missingFields.length > 0) {
          results.push({
            endpoint: `${endpoint.method} ${endpoint.path}`,
            success: false,
            error: `Missing fields: ${missingFields.join(', ')}`
          });
          continue;
        }
      }

      results.push({
        endpoint: `${endpoint.method} ${endpoint.path}`,
        success: true,
        status: response.status
      });

    } catch (error) {
      results.push({
        endpoint: `${endpoint.method} ${endpoint.path}`,
        success: false,
        error: error.message
      });
    }
  }

  return results;
}
```

---

## PHASE C: Test Verification

**Proves specified tests exist AND pass.**

```javascript
async function verifyTests(contract) {
  const tests = contract.test_ids;
  const results = [];

  for (const test of tests) {
    // 1. Check test file exists
    if (!fs.existsSync(test.file)) {
      results.push({
        test: `${test.file} :: ${test.test_name}`,
        success: false,
        error: `Test file not found: ${test.file}`
      });
      continue;
    }

    // 2. Check test name exists in file
    const testContent = fs.readFileSync(test.file, 'utf8');
    if (!testContent.includes(test.test_name)) {
      results.push({
        test: `${test.file} :: ${test.test_name}`,
        success: false,
        error: `Test "${test.test_name}" not found in file`
      });
      continue;
    }

    // 3. Run the specific test
    try {
      const { execSync } = require('child_process');
      const cmd = `npm test -- --testNamePattern="${test.test_name}" --testPathPattern="${test.file}" --passWithNoTests=false`;

      execSync(cmd, { stdio: 'pipe' });

      results.push({
        test: `${test.file} :: ${test.test_name}`,
        success: true
      });
    } catch (error) {
      results.push({
        test: `${test.file} :: ${test.test_name}`,
        success: false,
        error: `Test failed: ${error.message}`
      });
    }
  }

  return results;
}
```

---

## PHASE D: Staging Runtime Verification

**Executes the explicit verification steps from the contract.**

```javascript
async function verifyStagingSteps(contract, STAGING_URL) {
  const steps = contract.staging_verification_steps;
  const results = [];

  for (const step of steps) {
    const url = step.target.startsWith('http')
      ? step.target
      : `${STAGING_URL}${step.target}`;

    try {
      const response = await fetch(url, {
        method: step.method || 'GET',
        headers: { 'Content-Type': 'application/json' },
        body: step.body ? JSON.stringify(step.body) : undefined
      });

      const expected = step.expected;

      // Verify based on step type
      switch (step.type) {
        case 'http_status':
          if (response.status !== expected.status) {
            results.push({
              step: `${step.type}: ${step.target}`,
              success: false,
              error: `Expected status ${expected.status}, got ${response.status}`
            });
          } else {
            results.push({
              step: `${step.type}: ${step.target}`,
              success: true
            });
          }
          break;

        case 'json_field':
          const body = await response.json();
          if (expected.contains_field && !(expected.contains_field in body)) {
            results.push({
              step: `${step.type}: ${step.target}`,
              success: false,
              error: `Field "${expected.contains_field}" not in response`
            });
          } else if (expected.field_value && body[expected.contains_field] !== expected.field_value) {
            results.push({
              step: `${step.type}: ${step.target}`,
              success: false,
              error: `Field value mismatch`
            });
          } else {
            results.push({
              step: `${step.type}: ${step.target}`,
              success: true
            });
          }
          break;

        case 'health_check':
        case 'smoke_test':
          if (response.status >= 200 && response.status < 400) {
            results.push({
              step: `${step.type}: ${step.target}`,
              success: true
            });
          } else {
            results.push({
              step: `${step.type}: ${step.target}`,
              success: false,
              error: `Unhealthy: ${response.status}`
            });
          }
          break;
      }
    } catch (error) {
      results.push({
        step: `${step.type}: ${step.target}`,
        success: false,
        error: error.message
      });
    }
  }

  return results;
}
```

---

## VERIFICATION REPORT FORMAT

```
╔══════════════════════════════════════════════════════════════════════════════╗
║                    INTEGRATION VERIFICATION REPORT v2.1                       ║
║                    Sprint: S48 | Contract-Based Verification                  ║
╠══════════════════════════════════════════════════════════════════════════════╣
║ CONTRACTS LOADED: 3                                                           ║
╠══════════════════════════════════════════════════════════════════════════════╣

────────────────────────────────────────────────────────────────────────────────
CONTRACT: S48-F1 - Dark mode toggle
────────────────────────────────────────────────────────────────────────────────

PHASE A: UI Entrypoint
  File exists:     ✓ src/components/settings/ThemeToggle.tsx
  Renders at:      ✓ /settings → 200 OK

PHASE B: API Endpoints
  GET /api/user/preferences     ✓ 401 (auth protected)
  PUT /api/user/preferences     ✓ 401 (auth protected)

PHASE C: Tests
  tests/api/preferences.test.ts :: "should update theme preference"     ✓ PASS
  tests/components/ThemeToggle.test.tsx :: "should toggle..."          ✓ PASS

PHASE D: Staging Verification
  http_status: /api/user/preferences → 401                             ✓ PASS
  smoke_test: /settings → 200                                          ✓ PASS

CONTRACT STATUS: ✓ VERIFIED

────────────────────────────────────────────────────────────────────────────────
CONTRACT: S48-F2 - Theme context provider
────────────────────────────────────────────────────────────────────────────────

PHASE A: UI Entrypoint
  File exists:     ✓ src/contexts/ThemeContext.tsx
  Renders at:      ✓ / → 200 OK

PHASE B: API Endpoints
  (none defined)

PHASE C: Tests
  tests/contexts/ThemeContext.test.tsx :: "should persist..."          ✓ PASS

PHASE D: Staging Verification
  smoke_test: / → 200                                                  ✓ PASS

CONTRACT STATUS: ✓ VERIFIED

────────────────────────────────────────────────────────────────────────────────
CONTRACT: S48-F3 - Theme persistence API
────────────────────────────────────────────────────────────────────────────────

PHASE A: UI Entrypoint
  File exists:     ✓ app/api/user/preferences/route.ts

PHASE B: API Endpoints
  GET /api/user/preferences     ✓ 401
  PUT /api/user/preferences     ✓ 401

PHASE C: Tests
  tests/api/preferences.test.ts :: "should return 401..."             ✓ PASS
  tests/api/preferences.test.ts :: "should return user preferences"   ✗ FAIL
  tests/api/preferences.test.ts :: "should update preferences"        ✓ PASS

PHASE D: Staging Verification
  http_status: /api/user/preferences → 401                            ✓ PASS
  health_check: /api/health → 200                                     ✓ PASS

CONTRACT STATUS: ✗ FAILED (1 test failed)

╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  SUMMARY                                                                      ║
║                                                                               ║
║  Contracts Verified:  2 / 3                                                   ║
║  Contracts Failed:    1                                                       ║
║                                                                               ║
║  RESULT: FAILED                                                               ║
║                                                                               ║
║  Failures:                                                                    ║
║    1. S48-F3: Test "should return user preferences" failed                   ║
║                                                                               ║
║  Fix the failures and run /integrator again.                                 ║
║                                                                               ║
╚══════════════════════════════════════════════════════════════════════════════╝
```

---

## UPDATE SESSION STATE

```javascript
// Update session state with verification results
session.integration = {
  required: true,
  verified: allContractsPassed,
  verified_at: allContractsPassed ? new Date().toISOString() : null,
  contracts_defined: true,
  contracts_verified_count: passedCount,
  contracts_failed_count: failedCount,
  bypassed: false,
  bypass_reason: null
};

// Update each contract's verification_status
for (const contract of session.feature_contracts) {
  contract.verification_status = {
    ui_renders: verificationResults[contract.feature_id].ui.success,
    api_responds: verificationResults[contract.feature_id].api.every(a => a.success),
    tests_pass: verificationResults[contract.feature_id].tests.every(t => t.success),
    staging_verified: verificationResults[contract.feature_id].staging.every(s => s.success),
    last_verified_at: new Date().toISOString(),
    failure_reason: verificationResults[contract.feature_id].failureReason || null
  };
}

fs.writeFileSync('.claude/session/current.json', JSON.stringify(session, null, 2));
```

---

## WHAT git diff IS USED FOR (SECONDARY DIAGNOSTIC ONLY)

```bash
# ONLY as diagnostic info in report, NOT for verification decisions
echo "=== DIAGNOSTIC: Files Changed (informational only) ==="
git diff main..HEAD --name-only | head -20
```

---

## FAILURE CONDITIONS

**/integrator FAILS if:**

1. **No contracts defined** - session.feature_contracts is empty
2. **Any UI file missing** - contract.ui_entrypoint.path not found
3. **Any page doesn't render** - renders_at URL returns non-2xx/3xx
4. **Any API returns error** - unexpected status code
5. **Any test file missing** - test_ids[].file not found
6. **Any test name missing** - test name not in file
7. **Any test fails** - npm test returns non-zero
8. **Any staging check fails** - verification step fails

---

## BYPASS (FOUNDER ONLY)

```bash
/integrator --bypass --reason="Emergency hotfix"
```

Logs bypass:
```json
{
  "integration": {
    "verified": false,
    "bypassed": true,
    "bypass_reason": "Emergency hotfix",
    "bypassed_at": "2025-12-21T10:30:00Z"
  }
}
```

---

## PHASE E: BEHAVIOR TRACE VERIFICATION (NEW - v2.2)

**Added based on User & Enterprise Management v1.1 hostile audit failure.**

This phase catches the pattern: "files exist but aren't connected."

### E.1 Entry Point to DB Trace

For each feature that claims to create entities, verify the entry point actually calls the creation function:

```javascript
async function verifyEntryPointWiring(contract) {
  const wiring = contract.entry_point_wiring;
  if (!wiring) return { success: true, skipped: true };

  const results = { mustCall: [], mustNotCall: [] };

  // Read entry point file
  const entryPointPath = wiring.entry_point;
  if (!fs.existsSync(entryPointPath)) {
    return {
      success: false,
      error: `Entry point file not found: ${entryPointPath}`
    };
  }

  const content = fs.readFileSync(entryPointPath, 'utf8');

  // Check must_call functions are present
  for (const fn of wiring.must_call || []) {
    if (!content.includes(fn)) {
      results.mustCall.push({
        function: fn,
        found: false,
        error: `${entryPointPath} must call ${fn} but doesn't`
      });
    } else {
      results.mustCall.push({ function: fn, found: true });
    }
  }

  // Check must_not_call functions are absent
  for (const fn of wiring.must_not_call || []) {
    if (content.includes(fn)) {
      results.mustNotCall.push({
        function: fn,
        found: true,
        error: `${entryPointPath} must NOT call ${fn} (legacy) but still does`
      });
    } else {
      results.mustNotCall.push({ function: fn, found: false });
    }
  }

  const allMustCallFound = results.mustCall.every(r => r.found);
  const noForbiddenCalls = results.mustNotCall.every(r => !r.found);

  return {
    success: allMustCallFound && noForbiddenCalls,
    results
  };
}
```

### E.2 SQL Column Verification

Verify all SQL queries use correct column names:

```javascript
async function verifySqlColumns(contract) {
  const sqlQueries = contract.sql_queries;
  if (!sqlQueries || sqlQueries.length === 0) return { success: true, skipped: true };

  const results = [];

  for (const sq of sqlQueries) {
    if (!fs.existsSync(sq.file)) {
      results.push({
        file: sq.file,
        success: false,
        error: `SQL file not found: ${sq.file}`
      });
      continue;
    }

    const content = fs.readFileSync(sq.file, 'utf8');

    // Check for incorrect column usage
    // e.g., if table is 'enterprises' and primary_key is 'enterprise_id',
    // flag any 'WHERE id =' queries on that table
    const badPattern = new RegExp(
      `FROM\\s+${sq.table}[^;]*WHERE\\s+id\\s*=`, 'gi'
    );

    if (sq.primary_key !== 'id' && badPattern.test(content)) {
      results.push({
        file: sq.file,
        table: sq.table,
        success: false,
        error: `Uses 'WHERE id =' but ${sq.table} uses '${sq.primary_key}'`
      });
    } else {
      results.push({
        file: sq.file,
        table: sq.table,
        success: true
      });
    }
  }

  return {
    success: results.every(r => r.success),
    results
  };
}
```

### E.3 File Existence Verification

Verify all claimed files actually exist:

```javascript
async function verifyFilesExist(contract) {
  const filesCreated = contract.files_created;
  if (!filesCreated || filesCreated.length === 0) return { success: true, skipped: true };

  const results = [];

  for (const file of filesCreated) {
    if (fs.existsSync(file)) {
      results.push({ file, exists: true });
    } else {
      results.push({
        file,
        exists: false,
        error: `Claimed file does not exist: ${file}`
      });
    }
  }

  return {
    success: results.every(r => r.exists),
    results
  };
}
```

### E.4 Role Taxonomy Consistency

Verify role names are consistent:

```javascript
async function verifyRoleTaxonomy(contract) {
  const roleDeps = contract.role_dependencies;
  if (!roleDeps || roleDeps.length === 0) return { success: true, skipped: true };

  // Check that files using these roles don't mix old/new taxonomy
  const relevantFiles = [
    ...glob.sync('lib/security/**/*.ts'),
    ...glob.sync('lib/db/**/*.ts')
  ];

  const oldRoles = ['TENANT_USER', 'TENANT_ADMIN'];
  const newRoles = ['ENTERPRISE_USER', 'ENTERPRISE_ADMIN', 'INDIVIDUAL_USER'];

  const issues = [];

  for (const file of relevantFiles) {
    const content = fs.readFileSync(file, 'utf8');
    const usesOld = oldRoles.some(r => content.includes(r));
    const usesNew = newRoles.some(r => content.includes(r));

    if (usesOld && usesNew) {
      issues.push({
        file,
        error: 'Mixes old (TENANT_*) and new (ENTERPRISE_*) role taxonomy'
      });
    }
  }

  return {
    success: issues.length === 0,
    issues
  };
}
```

---

## PHASE E REPORT FORMAT

```
────────────────────────────────────────────────────────────────────────────────
PHASE E: BEHAVIOR TRACE VERIFICATION (v2.2)
────────────────────────────────────────────────────────────────────────────────

E.1 Entry Point Wiring:
  app/api/auth/signup/route.ts:
    ✓ calls getOrCreateEnterpriseForDomain
    ✓ does NOT call getOrCreateTenantForDomain (legacy)

E.2 SQL Column Names:
  lib/db/enterprises.ts:
    ✓ enterprises table uses enterprise_id correctly
  lib/security/enterprise-guards.ts:
    ✗ enterprises table uses 'WHERE id =' (should be enterprise_id)

E.3 File Existence:
  ✓ lib/enterprise/types.ts exists
  ✓ lib/enterprise/context.tsx exists
  ✗ lib/enterprise/hooks.ts MISSING

E.4 Role Taxonomy:
  ✗ lib/db/users.ts mixes TENANT_USER with ENTERPRISE_USER

PHASE E STATUS: ✗ FAILED (3 issues)
────────────────────────────────────────────────────────────────────────────────
```

---

## UPDATED VERIFICATION FLOW (v2.2)

```
/integrator
    │
    ├── Step 1: Load session state and contracts
    ├── Step 2: Validate contracts exist (FAIL if empty)
    ├── Step 3: Load environment config
    │
    ├── FOR EACH CONTRACT:
    │   ├── Phase A: UI Entrypoint Verification
    │   ├── Phase B: API Endpoint Verification
    │   ├── Phase C: Test Verification
    │   ├── Phase D: Staging Runtime Verification
    │   └── Phase E: BEHAVIOR TRACE VERIFICATION (NEW)
    │       ├── E.1 Entry Point Wiring
    │       ├── E.2 SQL Column Names
    │       ├── E.3 File Existence
    │       └── E.4 Role Taxonomy
    │
    ├── Step 4: Generate verification report
    ├── Step 5: Update session state
    └── Step 6: PASS or FAIL
```

---

## FAILURE CONDITIONS (Updated v2.2)

**/integrator FAILS if:**

1. **No contracts defined** - session.feature_contracts is empty
2. **Any UI file missing** - contract.ui_entrypoint.path not found
3. **Any page doesn't render** - renders_at URL returns non-2xx/3xx
4. **Any API returns error** - unexpected status code
5. **Any test file missing** - test_ids[].file not found
6. **Any test name missing** - test name not in file
7. **Any test fails** - npm test returns non-zero
8. **Any staging check fails** - verification step fails
9. **Entry point missing required call** - must_call function not found (NEW)
10. **Entry point has forbidden call** - must_not_call function still present (NEW)
11. **SQL column name wrong** - WHERE id = on non-id table (NEW)
12. **Claimed file missing** - files_created entry doesn't exist (NEW)
13. **Role taxonomy mixed** - Old and new roles in same file (NEW)

---

## GOLDEN RULES v2.2

1. **Contracts are truth** - No inference from git diff
2. **Runtime proof required** - Files existing is not enough
3. **Tests must pass** - Not just exist
4. **Staging must respond** - Not just be deployed
5. **All or nothing** - One failure = /integrator fails
6. **No patterns** - Explicit test names, explicit endpoints
7. **Entry points traced** - Verify signup/login call new functions (NEW)
8. **SQL columns verified** - No id vs enterprise_id bugs (NEW)
9. **Files actually exist** - Claims match reality (NEW)
10. **Roles consistent** - No TENANT_* mixed with ENTERPRISE_* (NEW)

---

## LESSONS FROM HOSTILE AUDIT (User & Enterprise v1.1)

| Failure | What Happened | How Phase E Prevents |
|---------|---------------|---------------------|
| Entry point disconnect | signup called getOrCreateTenantForDomain | E.1 checks must_call |
| Legacy function used | signup should call enterprise, called tenant | E.1 checks must_not_call |
| SQL column bug | WHERE id = $1 on enterprises table | E.2 validates columns |
| Missing files | lib/enterprise/* claimed but empty | E.3 verifies existence |
| Role taxonomy | TENANT_USER vs ENTERPRISE_USER | E.4 checks consistency |
