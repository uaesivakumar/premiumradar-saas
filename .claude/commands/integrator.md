# PremiumRadar Integration Verifier v2.1

**MANDATORY GATE** - Verifies Feature Wiring Contracts with RUNTIME PROOF.

**Version:** 2.1 - Contract-based verification (NO git diff)

---

## CRITICAL: CONTRACT-DRIVEN VERIFICATION

**/integrator does NOT infer wiring from git diff or grep.**

Verification is ONLY against Feature Wiring Contracts defined in `/start`.

If a feature has no contract → **FAIL**.

---

## VERIFICATION FLOW

```
/integrator
    │
    ├── Step 1: Load session state and contracts
    ├── Step 2: Validate contracts exist (FAIL if empty)
    ├── Step 3: Load environment config
    │
    ├── FOR EACH CONTRACT:
    │   ├── Phase A: UI Entrypoint Verification
    │   ├── Phase B: API Endpoint Verification
    │   ├── Phase C: Test Verification
    │   └── Phase D: Staging Runtime Verification
    │
    ├── Step 4: Generate verification report
    ├── Step 5: Update session state
    └── Step 6: PASS or FAIL
```

---

## STEP 1: Load Session State

```bash
SESSION_FILE=".claude/session/current.json"

if [ ! -f "$SESSION_FILE" ]; then
  echo "FAIL: No session state found"
  echo "Run /start first to initialize session and generate contracts"
  exit 1
fi

SESSION=$(cat "$SESSION_FILE")
```

---

## STEP 2: Validate Contracts Exist

```javascript
const session = JSON.parse(fs.readFileSync('.claude/session/current.json'));

if (!session.feature_contracts || session.feature_contracts.length === 0) {
  console.error("FAIL: No Feature Wiring Contracts defined");
  console.error("Cannot verify integration without contracts");
  console.error("/integrator requires contracts to be generated by /start");
  process.exit(1);
}

const contracts = session.feature_contracts;
console.log(`Loaded ${contracts.length} contracts for verification`);
```

---

## STEP 3: Load Environment Config

```javascript
const env = session.environment;

if (!env.staging_base_url) {
  console.error("FAIL: staging_base_url not defined in environment config");
  process.exit(1);
}

const STAGING_URL = env.staging_base_url;
const HEALTH_ENDPOINT = env.health_endpoint || '/api/health';
```

---

## PHASE A: UI Entrypoint Verification

**Proves the UI component/page exists AND renders.**

```javascript
async function verifyUIEntrypoint(contract) {
  const ui = contract.ui_entrypoint;
  const results = { exists: false, renders: null };

  // 1. Check file exists
  const filePath = ui.path;
  if (!fs.existsSync(filePath)) {
    return {
      success: false,
      error: `UI file not found: ${filePath}`
    };
  }
  results.exists = true;

  // 2. For pages/components with renders_at, verify runtime render
  if (ui.renders_at && ui.type !== 'api_only' && ui.type !== 'background') {
    const url = `${STAGING_URL}${ui.renders_at}`;
    const response = await fetch(url, {
      method: 'GET',
      redirect: 'follow'
    });

    if (response.status === 200) {
      results.renders = true;
    } else if (response.status === 401 || response.status === 403) {
      // Auth-protected pages are OK
      results.renders = true;
    } else {
      return {
        success: false,
        error: `Page does not render: ${url} returned ${response.status}`
      };
    }
  }

  return { success: true, results };
}
```

---

## PHASE B: API Endpoint Verification

**Proves each API endpoint exists AND responds correctly.**

```javascript
async function verifyAPIEndpoints(contract, STAGING_URL) {
  const endpoints = contract.api_endpoints;
  const results = [];

  for (const endpoint of endpoints) {
    const url = `${STAGING_URL}${endpoint.path}`;
    const expected = endpoint.expected_response_shape;

    try {
      const response = await fetch(url, {
        method: endpoint.method,
        headers: { 'Content-Type': 'application/json' },
        body: endpoint.method !== 'GET' && endpoint.required_request_fields
          ? JSON.stringify(Object.fromEntries(
              endpoint.required_request_fields.map(f => [f, 'test'])
            ))
          : undefined
      });

      // Check status
      if (expected.success_status && response.status !== expected.success_status) {
        // 401/403 is acceptable for auth-protected endpoints
        if (response.status !== 401 && response.status !== 403) {
          results.push({
            endpoint: `${endpoint.method} ${endpoint.path}`,
            success: false,
            error: `Expected status ${expected.success_status}, got ${response.status}`
          });
          continue;
        }
      }

      // If we got a JSON response, check required fields
      if (response.status === 200 && expected.required_fields) {
        const body = await response.json();
        const missingFields = expected.required_fields.filter(
          f => !(f in body)
        );
        if (missingFields.length > 0) {
          results.push({
            endpoint: `${endpoint.method} ${endpoint.path}`,
            success: false,
            error: `Missing fields: ${missingFields.join(', ')}`
          });
          continue;
        }
      }

      results.push({
        endpoint: `${endpoint.method} ${endpoint.path}`,
        success: true,
        status: response.status
      });

    } catch (error) {
      results.push({
        endpoint: `${endpoint.method} ${endpoint.path}`,
        success: false,
        error: error.message
      });
    }
  }

  return results;
}
```

---

## PHASE C: Test Verification

**Proves specified tests exist AND pass.**

```javascript
async function verifyTests(contract) {
  const tests = contract.test_ids;
  const results = [];

  for (const test of tests) {
    // 1. Check test file exists
    if (!fs.existsSync(test.file)) {
      results.push({
        test: `${test.file} :: ${test.test_name}`,
        success: false,
        error: `Test file not found: ${test.file}`
      });
      continue;
    }

    // 2. Check test name exists in file
    const testContent = fs.readFileSync(test.file, 'utf8');
    if (!testContent.includes(test.test_name)) {
      results.push({
        test: `${test.file} :: ${test.test_name}`,
        success: false,
        error: `Test "${test.test_name}" not found in file`
      });
      continue;
    }

    // 3. Run the specific test
    try {
      const { execSync } = require('child_process');
      const cmd = `npm test -- --testNamePattern="${test.test_name}" --testPathPattern="${test.file}" --passWithNoTests=false`;

      execSync(cmd, { stdio: 'pipe' });

      results.push({
        test: `${test.file} :: ${test.test_name}`,
        success: true
      });
    } catch (error) {
      results.push({
        test: `${test.file} :: ${test.test_name}`,
        success: false,
        error: `Test failed: ${error.message}`
      });
    }
  }

  return results;
}
```

---

## PHASE D: Staging Runtime Verification

**Executes the explicit verification steps from the contract.**

```javascript
async function verifyStagingSteps(contract, STAGING_URL) {
  const steps = contract.staging_verification_steps;
  const results = [];

  for (const step of steps) {
    const url = step.target.startsWith('http')
      ? step.target
      : `${STAGING_URL}${step.target}`;

    try {
      const response = await fetch(url, {
        method: step.method || 'GET',
        headers: { 'Content-Type': 'application/json' },
        body: step.body ? JSON.stringify(step.body) : undefined
      });

      const expected = step.expected;

      // Verify based on step type
      switch (step.type) {
        case 'http_status':
          if (response.status !== expected.status) {
            results.push({
              step: `${step.type}: ${step.target}`,
              success: false,
              error: `Expected status ${expected.status}, got ${response.status}`
            });
          } else {
            results.push({
              step: `${step.type}: ${step.target}`,
              success: true
            });
          }
          break;

        case 'json_field':
          const body = await response.json();
          if (expected.contains_field && !(expected.contains_field in body)) {
            results.push({
              step: `${step.type}: ${step.target}`,
              success: false,
              error: `Field "${expected.contains_field}" not in response`
            });
          } else if (expected.field_value && body[expected.contains_field] !== expected.field_value) {
            results.push({
              step: `${step.type}: ${step.target}`,
              success: false,
              error: `Field value mismatch`
            });
          } else {
            results.push({
              step: `${step.type}: ${step.target}`,
              success: true
            });
          }
          break;

        case 'health_check':
        case 'smoke_test':
          if (response.status >= 200 && response.status < 400) {
            results.push({
              step: `${step.type}: ${step.target}`,
              success: true
            });
          } else {
            results.push({
              step: `${step.type}: ${step.target}`,
              success: false,
              error: `Unhealthy: ${response.status}`
            });
          }
          break;
      }
    } catch (error) {
      results.push({
        step: `${step.type}: ${step.target}`,
        success: false,
        error: error.message
      });
    }
  }

  return results;
}
```

---

## VERIFICATION REPORT FORMAT

```
╔══════════════════════════════════════════════════════════════════════════════╗
║                    INTEGRATION VERIFICATION REPORT v2.1                       ║
║                    Sprint: S48 | Contract-Based Verification                  ║
╠══════════════════════════════════════════════════════════════════════════════╣
║ CONTRACTS LOADED: 3                                                           ║
╠══════════════════════════════════════════════════════════════════════════════╣

────────────────────────────────────────────────────────────────────────────────
CONTRACT: S48-F1 - Dark mode toggle
────────────────────────────────────────────────────────────────────────────────

PHASE A: UI Entrypoint
  File exists:     ✓ src/components/settings/ThemeToggle.tsx
  Renders at:      ✓ /settings → 200 OK

PHASE B: API Endpoints
  GET /api/user/preferences     ✓ 401 (auth protected)
  PUT /api/user/preferences     ✓ 401 (auth protected)

PHASE C: Tests
  tests/api/preferences.test.ts :: "should update theme preference"     ✓ PASS
  tests/components/ThemeToggle.test.tsx :: "should toggle..."          ✓ PASS

PHASE D: Staging Verification
  http_status: /api/user/preferences → 401                             ✓ PASS
  smoke_test: /settings → 200                                          ✓ PASS

CONTRACT STATUS: ✓ VERIFIED

────────────────────────────────────────────────────────────────────────────────
CONTRACT: S48-F2 - Theme context provider
────────────────────────────────────────────────────────────────────────────────

PHASE A: UI Entrypoint
  File exists:     ✓ src/contexts/ThemeContext.tsx
  Renders at:      ✓ / → 200 OK

PHASE B: API Endpoints
  (none defined)

PHASE C: Tests
  tests/contexts/ThemeContext.test.tsx :: "should persist..."          ✓ PASS

PHASE D: Staging Verification
  smoke_test: / → 200                                                  ✓ PASS

CONTRACT STATUS: ✓ VERIFIED

────────────────────────────────────────────────────────────────────────────────
CONTRACT: S48-F3 - Theme persistence API
────────────────────────────────────────────────────────────────────────────────

PHASE A: UI Entrypoint
  File exists:     ✓ app/api/user/preferences/route.ts

PHASE B: API Endpoints
  GET /api/user/preferences     ✓ 401
  PUT /api/user/preferences     ✓ 401

PHASE C: Tests
  tests/api/preferences.test.ts :: "should return 401..."             ✓ PASS
  tests/api/preferences.test.ts :: "should return user preferences"   ✗ FAIL
  tests/api/preferences.test.ts :: "should update preferences"        ✓ PASS

PHASE D: Staging Verification
  http_status: /api/user/preferences → 401                            ✓ PASS
  health_check: /api/health → 200                                     ✓ PASS

CONTRACT STATUS: ✗ FAILED (1 test failed)

╠══════════════════════════════════════════════════════════════════════════════╣
║                                                                               ║
║  SUMMARY                                                                      ║
║                                                                               ║
║  Contracts Verified:  2 / 3                                                   ║
║  Contracts Failed:    1                                                       ║
║                                                                               ║
║  RESULT: FAILED                                                               ║
║                                                                               ║
║  Failures:                                                                    ║
║    1. S48-F3: Test "should return user preferences" failed                   ║
║                                                                               ║
║  Fix the failures and run /integrator again.                                 ║
║                                                                               ║
╚══════════════════════════════════════════════════════════════════════════════╝
```

---

## UPDATE SESSION STATE

```javascript
// Update session state with verification results
session.integration = {
  required: true,
  verified: allContractsPassed,
  verified_at: allContractsPassed ? new Date().toISOString() : null,
  contracts_defined: true,
  contracts_verified_count: passedCount,
  contracts_failed_count: failedCount,
  bypassed: false,
  bypass_reason: null
};

// Update each contract's verification_status
for (const contract of session.feature_contracts) {
  contract.verification_status = {
    ui_renders: verificationResults[contract.feature_id].ui.success,
    api_responds: verificationResults[contract.feature_id].api.every(a => a.success),
    tests_pass: verificationResults[contract.feature_id].tests.every(t => t.success),
    staging_verified: verificationResults[contract.feature_id].staging.every(s => s.success),
    last_verified_at: new Date().toISOString(),
    failure_reason: verificationResults[contract.feature_id].failureReason || null
  };
}

fs.writeFileSync('.claude/session/current.json', JSON.stringify(session, null, 2));
```

---

## WHAT git diff IS USED FOR (SECONDARY DIAGNOSTIC ONLY)

```bash
# ONLY as diagnostic info in report, NOT for verification decisions
echo "=== DIAGNOSTIC: Files Changed (informational only) ==="
git diff main..HEAD --name-only | head -20
```

---

## FAILURE CONDITIONS

**/integrator FAILS if:**

1. **No contracts defined** - session.feature_contracts is empty
2. **Any UI file missing** - contract.ui_entrypoint.path not found
3. **Any page doesn't render** - renders_at URL returns non-2xx/3xx
4. **Any API returns error** - unexpected status code
5. **Any test file missing** - test_ids[].file not found
6. **Any test name missing** - test name not in file
7. **Any test fails** - npm test returns non-zero
8. **Any staging check fails** - verification step fails

---

## BYPASS (FOUNDER ONLY)

```bash
/integrator --bypass --reason="Emergency hotfix"
```

Logs bypass:
```json
{
  "integration": {
    "verified": false,
    "bypassed": true,
    "bypass_reason": "Emergency hotfix",
    "bypassed_at": "2025-12-21T10:30:00Z"
  }
}
```

---

## GOLDEN RULES v2.1

1. **Contracts are truth** - No inference from git diff
2. **Runtime proof required** - Files existing is not enough
3. **Tests must pass** - Not just exist
4. **Staging must respond** - Not just be deployed
5. **All or nothing** - One failure = /integrator fails
6. **No patterns** - Explicit test names, explicit endpoints
