/**
 * Persona Wrapper Hook - S47
 *
 * Wraps message formatting with persona and tone application.
 *
 * Pattern:
 *   1. Message is generated by agent
 *   2. PersonaKernel applies VERTICAL-SPECIFIC persona traits
 *   3. TonePackManager applies selected tone
 *   4. PersonalizationMemory learns user preferences
 *   5. THEN formats the message (does NOT replace generation)
 *
 * CRITICAL: This hook FORMATS messages, it does NOT replace generation.
 *
 * IMPORTANT: Persona MUST respect vertical config!
 *   Banking persona ≠ Insurance persona ≠ Real Estate persona
 *   SIVA switches personalities dynamically based on salesContext.
 */

'use client';

import { useCallback, useMemo } from 'react';
import { usePersonaStore, selectCurrentTone, selectAvailablePersonas } from '@/lib/stores/persona-store';
import { useSalesContextStore } from '@/lib/stores/sales-context-store';
import { getPersonaForVertical, type VerticalPersona } from '../persona/vertical-personas';
import type {
  ToneType,
  OutreachToneType,
  PersonaConfig,
  PersonaApplicationResult,
  PersonaWrapperResult,
} from '../types';

/**
 * Persona Wrapper Hook
 *
 * Usage:
 *   const { applyTone, currentTone, setTone, persona } = usePersonaWrapper();
 *   const formattedMessage = applyTone(rawMessage);
 */
export function usePersonaWrapper(): PersonaWrapperResult {
  // Get sales context for vertical-aware persona switching
  const salesContext = useSalesContextStore((state) => state.context);

  const {
    activePersona: storePersona,
    activeTonePack,
    isApplying,
    error,
    setActiveTone,
    applyToContent,
    getSuggestedTone,
  } = usePersonaStore();

  // Get vertical-specific persona (dynamic switching)
  const verticalPersona = useMemo(() => {
    return getPersonaForVertical(salesContext.vertical, salesContext.subVertical);
  }, [salesContext.vertical, salesContext.subVertical]);

  // Merge store persona with vertical-specific overrides
  const activePersona = useMemo(() => ({
    ...storePersona,
    // Override with vertical-specific values
    baseTone: verticalPersona.baseTone,
    outreachTone: verticalPersona.outreachTone,
    traits: verticalPersona.traits.map(t => ({
      name: t.name,
      description: t.description,
      intensity: t.intensity,
    })),
    description: verticalPersona.description,
    // Keep store name but add vertical context
    name: `${verticalPersona.name} (${salesContext.vertical})`,
  }), [storePersona, verticalPersona, salesContext.vertical]);

  /**
   * Apply tone and persona to a message
   */
  const applyTone = useCallback(
    (message: string, context?: {
      isOutreach?: boolean;
      agentType?: string;
      intentType?: string;
    }): string => {
      const result = applyToContent(message, context);
      return result.modified;
    },
    [applyToContent]
  );

  /**
   * Apply tone with full result details
   */
  const applyToneWithDetails = useCallback(
    (message: string, context?: {
      isOutreach?: boolean;
      agentType?: string;
      intentType?: string;
    }): PersonaApplicationResult => {
      return applyToContent(message, context);
    },
    [applyToContent]
  );

  /**
   * Set the active tone
   */
  const setTone = useCallback(
    (tone: ToneType | OutreachToneType) => {
      setActiveTone(tone);
    },
    [setActiveTone]
  );

  /**
   * Get suggested tone for context
   */
  const suggestToneFor = useCallback(
    (context: {
      isOutreach: boolean;
      recipientRole?: string;
      urgency?: 'low' | 'medium' | 'high';
      relationship?: 'new' | 'warm' | 'existing';
    }) => {
      return getSuggestedTone(context);
    },
    [getSuggestedTone]
  );

  /**
   * Current tone (for display/compatibility)
   */
  const currentTone: ToneType = activePersona.baseTone;

  /**
   * Persona config (for display/compatibility)
   * Maps new format to legacy format for backwards compatibility
   */
  const persona: PersonaConfig = useMemo(() => ({
    id: activePersona.id,
    name: activePersona.name,
    basePersonality: activePersona.description,
    toneDefault: activePersona.baseTone,
    outreachToneDefault: activePersona.outreachTone,
    traits: activePersona.traits.map(t => ({
      name: t.name,
      description: t.description,
      weight: t.intensity,
    })),
    vocabulary: [],
    avoidWords: [],
  }), [activePersona]);

  /**
   * Available tones for selection
   */
  const availableTones = useMemo(() => {
    const baseTones: ToneType[] = ['professional', 'friendly', 'concise', 'detailed'];
    const outreachTones: OutreachToneType[] = ['executive', 'consultative'];
    return { base: baseTones, outreach: outreachTones };
  }, []);

  /**
   * Tone metrics for current tone pack
   */
  const toneInfo = useMemo(() => {
    if (!activeTonePack) return null;
    return {
      id: activeTonePack.id,
      name: activeTonePack.name,
      tone: activeTonePack.tone,
    };
  }, [activeTonePack]);

  return {
    // Core functions
    applyTone,
    applyToneWithDetails,
    setTone,
    suggestToneFor,

    // Current state
    currentTone,
    persona,
    toneInfo,
    availableTones,

    // Vertical-aware persona (SIVA switches dynamically)
    verticalPersona: {
      id: verticalPersona.id,
      name: verticalPersona.name,
      vertical: salesContext.vertical,
      subVertical: salesContext.subVertical,
      baseTone: verticalPersona.baseTone,
      outreachTone: verticalPersona.outreachTone,
      communicationStyle: verticalPersona.communicationStyle,
    },

    // Status
    isApplying,
    error,
  };
}
