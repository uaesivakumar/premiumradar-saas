/**
 * Live Object Factory - S46
 *
 * Creates and manages Live Objects from base OutputObjects.
 * Provides the foundation for object-centric interactions.
 */

import type { OutputObject } from '@/lib/stores/siva-store';
import type {
  LiveObject,
  ObjectLink,
  ObjectThread,
  ObjectInspectorData,
  ObjectHistoryEntry,
  ObjectState,
  CreateLiveObjectOptions,
  SourceAttribution,
} from './types';

// =============================================================================
// Factory Functions
// =============================================================================

/**
 * Create a Live Object from a base OutputObject
 */
export function createLiveObject(options: CreateLiveObjectOptions): LiveObject {
  const {
    baseObject,
    isLive = false,
    updateFrequency = 0,
    linkedObjectIds = [],
    initialThread,
  } = options;

  const now = new Date();
  const objectId = baseObject.id;

  // Create linked objects
  const linkedObjects: ObjectLink[] = linkedObjectIds.map((targetId, index) => ({
    id: `link-${objectId}-${targetId}`,
    sourceId: objectId,
    targetId,
    relationship: 'related_to',
    strength: 0.5,
    createdAt: now,
  }));

  // Create initial thread if provided
  const threads: ObjectThread[] = [];
  if (initialThread) {
    threads.push({
      ...initialThread,
      id: `thread-${objectId}-${Date.now()}`,
      objectId,
      createdAt: now,
      updatedAt: now,
    });
  }

  // Create inspector data
  const inspectorData = createInspectorData(baseObject);

  // Create the live object
  const liveObject: LiveObject = {
    ...baseObject,
    isLive,
    lastUpdate: now,
    updateFrequency,
    linkedObjects,
    threads,
    inspectorData,
    state: 'active',
  };

  return liveObject;
}

/**
 * Create inspector data from base object
 */
function createInspectorData(baseObject: OutputObject): ObjectInspectorData {
  // Extract metadata
  const metadata = baseObject.data || {};

  // Create initial history entry
  const history: ObjectHistoryEntry[] = [
    {
      id: `hist-${baseObject.id}-create`,
      action: 'created',
      timestamp: baseObject.timestamp,
      details: `Object created by ${baseObject.agent} agent`,
    },
  ];

  // Determine sources
  const sources: SourceAttribution[] = [
    {
      name: `${baseObject.agent} Agent`,
      type: 'ai',
      timestamp: baseObject.timestamp,
      confidence: 0.85,
    },
  ];

  return {
    metadata,
    signals: [],
    reasoning: {
      steps: [],
      conclusion: `Generated by ${baseObject.agent} agent`,
      confidence: 0.8,
      duration: 0,
    },
    history,
    sources,
  };
}

/**
 * Update a Live Object's state
 */
export function updateObjectState(
  object: LiveObject,
  newState: ObjectState,
  reason?: string
): LiveObject {
  const now = new Date();

  // Add history entry
  const historyEntry: ObjectHistoryEntry = {
    id: `hist-${object.id}-${Date.now()}`,
    action: newState === 'archived' ? 'archived' : 'updated',
    timestamp: now,
    details: reason || `State changed to ${newState}`,
    previousValue: object.state,
    newValue: newState,
  };

  return {
    ...object,
    state: newState,
    lastUpdate: now,
    inspectorData: {
      ...object.inspectorData,
      history: [...object.inspectorData.history, historyEntry],
    },
  };
}

/**
 * Enrich a Live Object with evidence and reasoning
 */
export function enrichLiveObject(
  object: LiveObject,
  enrichment: {
    signals?: ObjectInspectorData['signals'];
    reasoning?: ObjectInspectorData['reasoning'];
    sources?: SourceAttribution[];
  }
): LiveObject {
  const now = new Date();

  // Add enrichment history entry
  const historyEntry: ObjectHistoryEntry = {
    id: `hist-${object.id}-enrich-${Date.now()}`,
    action: 'enriched',
    timestamp: now,
    details: `Enriched with ${enrichment.signals?.length || 0} signals`,
  };

  return {
    ...object,
    lastUpdate: now,
    inspectorData: {
      ...object.inspectorData,
      signals: enrichment.signals || object.inspectorData.signals,
      reasoning: enrichment.reasoning || object.inspectorData.reasoning,
      sources: enrichment.sources
        ? [...object.inspectorData.sources, ...enrichment.sources]
        : object.inspectorData.sources,
      history: [...object.inspectorData.history, historyEntry],
    },
  };
}

/**
 * Link two objects together
 */
export function linkObjects(
  source: LiveObject,
  targetId: string,
  relationship: ObjectLink['relationship'] = 'related_to',
  strength: number = 0.5
): LiveObject {
  const now = new Date();

  // Check if link already exists
  const existingLink = source.linkedObjects.find(l => l.targetId === targetId);
  if (existingLink) {
    return source;
  }

  // Create new link
  const newLink: ObjectLink = {
    id: `link-${source.id}-${targetId}-${Date.now()}`,
    sourceId: source.id,
    targetId,
    relationship,
    strength,
    createdAt: now,
  };

  // Add history entry
  const historyEntry: ObjectHistoryEntry = {
    id: `hist-${source.id}-link-${Date.now()}`,
    action: 'linked',
    timestamp: now,
    details: `Linked to object ${targetId} (${relationship})`,
    newValue: targetId,
  };

  return {
    ...source,
    lastUpdate: now,
    linkedObjects: [...source.linkedObjects, newLink],
    inspectorData: {
      ...source.inspectorData,
      history: [...source.inspectorData.history, historyEntry],
    },
  };
}

/**
 * Unlink two objects
 */
export function unlinkObjects(source: LiveObject, targetId: string): LiveObject {
  const now = new Date();

  // Find and remove link
  const updatedLinks = source.linkedObjects.filter(l => l.targetId !== targetId);

  if (updatedLinks.length === source.linkedObjects.length) {
    // No link was removed
    return source;
  }

  // Add history entry
  const historyEntry: ObjectHistoryEntry = {
    id: `hist-${source.id}-unlink-${Date.now()}`,
    action: 'unlinked',
    timestamp: now,
    details: `Unlinked from object ${targetId}`,
    previousValue: targetId,
  };

  return {
    ...source,
    lastUpdate: now,
    linkedObjects: updatedLinks,
    inspectorData: {
      ...source.inspectorData,
      history: [...source.inspectorData.history, historyEntry],
    },
  };
}

/**
 * Refresh/update a Live Object's data
 */
export function refreshObject(
  object: LiveObject,
  newData: Partial<OutputObject['data']>
): LiveObject {
  const now = new Date();

  // Add history entry
  const historyEntry: ObjectHistoryEntry = {
    id: `hist-${object.id}-refresh-${Date.now()}`,
    action: 'refreshed',
    timestamp: now,
    details: 'Object data refreshed',
    previousValue: object.data,
    newValue: { ...object.data, ...newData },
  };

  return {
    ...object,
    data: { ...object.data, ...newData },
    lastUpdate: now,
    state: 'active',
    inspectorData: {
      ...object.inspectorData,
      metadata: { ...object.inspectorData.metadata, ...newData },
      history: [...object.inspectorData.history, historyEntry],
    },
  };
}

/**
 * Check if an object is stale (needs refresh)
 */
export function isObjectStale(object: LiveObject, maxAgeMs: number = 300000): boolean {
  if (!object.isLive) return false;
  if (object.state === 'archived') return false;

  const age = Date.now() - object.lastUpdate.getTime();
  return age > maxAgeMs;
}

/**
 * Get object age in human-readable format
 */
export function getObjectAge(object: LiveObject): string {
  const ageMs = Date.now() - object.lastUpdate.getTime();
  const seconds = Math.floor(ageMs / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);

  if (days > 0) return `${days}d ago`;
  if (hours > 0) return `${hours}h ago`;
  if (minutes > 0) return `${minutes}m ago`;
  return 'just now';
}
