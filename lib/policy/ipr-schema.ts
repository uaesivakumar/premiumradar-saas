/**
 * IPR Schema - Intermediate Policy Representation
 * S398: Policy Interpretation Engine
 *
 * This defines the schema for the structured representation of enrichment policies.
 * IPR is:
 * - Generated by LLM from plain English policy text (authoring-time)
 * - Human-readable and editable
 * - Approved by founder before becoming active
 * - Compiled to deterministic execution plan (Phase 2)
 *
 * Part of Phase 1: Policy Compiler (Foundational)
 * Master Implementation Plan - LOCKED
 */

/**
 * Condition operators for policy rules
 */
export type ConditionOperator =
  | 'eq' // equals
  | 'neq' // not equals
  | 'gt' // greater than
  | 'gte' // greater than or equal
  | 'lt' // less than
  | 'lte' // less than or equal
  | 'in' // in array
  | 'not_in' // not in array
  | 'contains' // string contains
  | 'not_contains' // string does not contain
  | 'exists' // field exists and is not null
  | 'not_exists'; // field is null or missing

/**
 * A single condition extracted from the policy
 *
 * Example:
 * "If company is large (500+ employees)" becomes:
 * { field: "headcount", operator: "gte", value: 500, description: "Large company" }
 */
export interface IPRCondition {
  field: string; // e.g., "headcount", "geography", "industry", "company_age_years"
  operator: ConditionOperator;
  value: string | number | boolean | string[] | number[];
  description: string; // Human-readable explanation
}

/**
 * A named threshold extracted from the policy
 *
 * Example:
 * "large (500+ employees)" becomes:
 * { name: "large_company", field: "headcount", value: 500, unit: "employees" }
 */
export interface IPRThreshold {
  name: string; // e.g., "large_company", "small_company", "mid_size"
  field: string; // e.g., "headcount", "revenue", "age_years"
  value: number;
  unit: string; // e.g., "employees", "USD", "years"
  comparison: 'gte' | 'lte' | 'gt' | 'lt'; // How to compare (>=, <=, >, <)
}

/**
 * Target roles for a specific company segment
 *
 * Example:
 * "If company is large, prioritize HR Head and Payroll Manager" becomes:
 * {
 *   company_size_range: { min: 500, max: null },
 *   titles: ["HR Head", "Chief People Officer", "Payroll Manager"],
 *   priority: 1,
 *   reason: "Large company - operational contacts for payroll"
 * }
 */
export interface IPRTargetRole {
  // SCOPE DECLARATION (exactly ONE must be set)
  // Option 1: Applies to all companies regardless of size/conditions
  applies_to_all?: boolean;

  // Option 2: Company size range this applies to
  company_size_range?: {
    min: number | null;
    max: number | null;
  };

  // Option 3: Condition-based scope (signals, entity type, etc.)
  conditions?: IPRCondition[];

  // Target job titles (in priority order)
  titles: string[];

  // Priority level (1 = highest)
  priority: number;

  // Human-readable reason for this targeting
  reason: string;
}

/**
 * Fallback behavior when no conditions match
 */
export interface IPRFallbackBehavior {
  // What to do when no rules match
  when_no_match: 'skip' | 'use_default' | 'deprioritize' | 'flag_for_review';

  // Default roles to use if when_no_match is 'use_default'
  default_roles?: string[];

  // Priority modifier if when_no_match is 'deprioritize'
  deprioritize_factor?: number; // e.g., 0.5 = half priority
}

/**
 * How to handle uncertainty in data
 */
export interface IPRUncertaintyHandling {
  // What to do when company size is unknown
  when_size_unknown: 'assume_mid' | 'assume_small' | 'skip' | 'flag_for_review';

  // What to do when geography is unclear
  when_geography_unclear: 'proceed' | 'deprioritize' | 'skip' | 'flag_for_review';

  // What to do when industry doesn't match
  when_industry_mismatch: 'proceed' | 'deprioritize' | 'skip';

  // General data quality threshold
  minimum_data_confidence?: number; // 0-1, skip if below this
}

/**
 * Skip rules - conditions that should exclude entities entirely
 */
export interface IPRSkipRule {
  condition: IPRCondition;
  reason: string;
}

/**
 * The complete Intermediate Policy Representation
 *
 * This is what gets:
 * 1. Generated by LLM from plain English
 * 2. Reviewed and edited by founder
 * 3. Approved to become active
 * 4. Compiled to execution plan (Phase 2)
 */
export interface IntermediatePolicyRepresentation {
  // Schema version for forward compatibility
  schema_version: '1.0';

  // Metadata
  generated_at: string; // ISO timestamp
  generated_from_text_hash: string; // Hash of source text for change detection

  // Named thresholds (reusable across rules)
  thresholds: IPRThreshold[];

  // Target role rules (ordered by priority)
  target_roles: IPRTargetRole[];

  // Skip rules (entities to exclude entirely)
  skip_rules: IPRSkipRule[];

  // Fallback behavior
  fallback_behavior: IPRFallbackBehavior;

  // Uncertainty handling
  uncertainty_handling: IPRUncertaintyHandling;

  // Raw conditions (for complex rules not covered above)
  additional_conditions?: IPRCondition[];

  // Interpretation notes (from LLM)
  interpretation_notes?: string[];
}

/**
 * Create an empty IPR with NO assumptions
 *
 * LOSSLESS PRINCIPLE: Only include what's explicitly stated in the policy.
 * If the policy doesn't specify something, leave it EMPTY or mark as UNSTATED.
 * NEVER assume mid, NEVER insert default roles.
 */
export function createEmptyIPR(): IntermediatePolicyRepresentation {
  return {
    schema_version: '1.0',
    generated_at: new Date().toISOString(),
    generated_from_text_hash: '',
    thresholds: [],
    target_roles: [],
    skip_rules: [],
    // LOSSLESS: No defaults - only populate from explicit policy statements
    fallback_behavior: {
      when_no_match: 'flag_for_review', // Conservative: flag if no match, don't assume
    },
    // LOSSLESS: No assumptions about uncertainty - leave for explicit policy
    uncertainty_handling: {
      when_size_unknown: 'flag_for_review', // Conservative: don't assume size
      when_geography_unclear: 'flag_for_review', // Conservative: don't assume
      when_industry_mismatch: 'skip', // Conservative: skip if industry doesn't match (only option without assumptions)
    },
  };
}

/**
 * Validate an IPR structure
 */
export function validateIPR(ipr: unknown): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  if (!ipr || typeof ipr !== 'object') {
    return { valid: false, errors: ['IPR must be an object'] };
  }

  const data = ipr as Record<string, unknown>;

  // Check schema version
  if (data.schema_version !== '1.0') {
    errors.push(`Invalid schema_version: ${data.schema_version}. Expected: 1.0`);
  }

  // Check required arrays
  if (!Array.isArray(data.target_roles)) {
    errors.push('target_roles must be an array');
  } else if (data.target_roles.length === 0) {
    errors.push('At least one target_role is required');
  } else {
    // Validate each target role
    (data.target_roles as IPRTargetRole[]).forEach((role, i) => {
      if (!role.titles || role.titles.length === 0) {
        errors.push(`target_roles[${i}].titles must have at least one title`);
      }
      if (typeof role.priority !== 'number' || role.priority < 1) {
        errors.push(`target_roles[${i}].priority must be a positive number`);
      }
      if (!role.reason) {
        errors.push(`target_roles[${i}].reason is required`);
      }
    });
  }

  // Check fallback behavior
  if (!data.fallback_behavior || typeof data.fallback_behavior !== 'object') {
    errors.push('fallback_behavior is required');
  } else {
    const fb = data.fallback_behavior as IPRFallbackBehavior;
    const validActions = ['skip', 'use_default', 'deprioritize', 'flag_for_review'];
    if (!validActions.includes(fb.when_no_match)) {
      errors.push(`fallback_behavior.when_no_match must be one of: ${validActions.join(', ')}`);
    }
  }

  // Check uncertainty handling
  if (!data.uncertainty_handling || typeof data.uncertainty_handling !== 'object') {
    errors.push('uncertainty_handling is required');
  }

  return { valid: errors.length === 0, errors };
}

/**
 * Hash policy text for change detection
 */
export function hashPolicyText(text: string): string {
  // Simple hash for change detection
  let hash = 0;
  for (let i = 0; i < text.length; i++) {
    const char = text.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash; // Convert to 32-bit integer
  }
  return Math.abs(hash).toString(16);
}
