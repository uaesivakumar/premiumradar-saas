-- S400: Enrichment Policy Versioning & Audit
-- Create enrichment_policy_versions table for immutable version tracking
--
-- This table stores:
-- - Each version of the policy text
-- - The interpreted IPR (from LLM)
-- - Approval status and audit trail
-- - Compiled policy (for Phase 2 runtime)
--
-- Part of Phase 1: Policy Compiler (Foundational)
-- Master Implementation Plan - LOCKED

-- Create enrichment_policy_versions table
CREATE TABLE IF NOT EXISTS enrichment_policy_versions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  sub_vertical_id UUID NOT NULL REFERENCES os_sub_verticals(id) ON DELETE CASCADE,

  -- Version tracking
  version INTEGER NOT NULL,

  -- Policy content
  policy_text TEXT NOT NULL,

  -- Interpreted IPR (from S398 LLM interpretation)
  -- This is the Intermediate Policy Representation
  -- Structure: { conditions: [], thresholds: [], target_roles: [], fallback_behavior: {}, uncertainty_handling: {} }
  interpreted_ipr JSONB,

  -- Interpretation metadata
  interpretation_confidence DECIMAL(5,4), -- 0.0000 to 1.0000
  interpretation_warnings JSONB, -- Array of warning strings
  interpreted_at TIMESTAMPTZ,
  interpreted_by VARCHAR(255), -- Could be 'system' for LLM or user for manual edits

  -- Compiled policy (for Phase 2 runtime)
  -- This is the deterministic execution plan
  -- Only populated after IPR is approved and compiled
  compiled_policy JSONB,
  compiled_at TIMESTAMPTZ,

  -- Approval workflow
  status VARCHAR(20) NOT NULL DEFAULT 'draft'
    CHECK (status IN ('draft', 'pending_approval', 'approved', 'rejected', 'deprecated')),

  -- Approval audit
  approved_by VARCHAR(255),
  approved_at TIMESTAMPTZ,
  approval_notes TEXT,

  -- Rejection audit
  rejected_by VARCHAR(255),
  rejected_at TIMESTAMPTZ,
  rejection_reason TEXT,

  -- Deprecation audit
  deprecated_by VARCHAR(255),
  deprecated_at TIMESTAMPTZ,
  deprecation_reason TEXT,

  -- Creation audit
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  created_by VARCHAR(255) NOT NULL,

  -- Unique version per sub-vertical
  CONSTRAINT unique_policy_version UNIQUE (sub_vertical_id, version)
);

-- Index for quick lookup of active/pending versions
CREATE INDEX IF NOT EXISTS idx_epv_sub_vertical_status
ON enrichment_policy_versions (sub_vertical_id, status);

-- Index for finding latest approved version
CREATE INDEX IF NOT EXISTS idx_epv_approved
ON enrichment_policy_versions (sub_vertical_id, status, version DESC)
WHERE status = 'approved';

-- Index for audit queries
CREATE INDEX IF NOT EXISTS idx_epv_created_at
ON enrichment_policy_versions (created_at DESC);

-- Add comments
COMMENT ON TABLE enrichment_policy_versions IS
'Immutable version history for enrichment policies.
Each row represents one version of a policy, from draft through approval.
The interpreted_ipr field contains the LLM-extracted structured representation.
The compiled_policy field (Phase 2) contains the runtime-ready execution plan.';

COMMENT ON COLUMN enrichment_policy_versions.interpreted_ipr IS
'Intermediate Policy Representation (IPR) - human-readable structured format.
Generated by LLM from policy_text. Can be manually edited before approval.
Schema: { conditions: [], thresholds: [], target_roles: [], fallback_behavior: {}, uncertainty_handling: {} }';

COMMENT ON COLUMN enrichment_policy_versions.compiled_policy IS
'Compiled execution plan for runtime. Generated from approved IPR in Phase 2.
Contains deterministic SQL filters and role prioritization logic.
NO LLM interpretation at runtime - this is the source of truth.';

COMMENT ON COLUMN enrichment_policy_versions.status IS
'Policy lifecycle status:
- draft: Initial state, being written
- pending_approval: IPR generated, awaiting founder review
- approved: Founder approved, ready for compilation (Phase 2)
- rejected: Founder rejected interpretation
- deprecated: Previously approved, now superseded by newer version';

-- Function to get active policy version for a sub-vertical
CREATE OR REPLACE FUNCTION get_active_policy_version(p_sub_vertical_id UUID)
RETURNS TABLE (
  version_id UUID,
  version INTEGER,
  policy_text TEXT,
  interpreted_ipr JSONB,
  compiled_policy JSONB,
  approved_at TIMESTAMPTZ,
  approved_by VARCHAR(255)
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    epv.id as version_id,
    epv.version,
    epv.policy_text,
    epv.interpreted_ipr,
    epv.compiled_policy,
    epv.approved_at,
    epv.approved_by
  FROM enrichment_policy_versions epv
  WHERE epv.sub_vertical_id = p_sub_vertical_id
    AND epv.status = 'approved'
  ORDER BY epv.version DESC
  LIMIT 1;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION get_active_policy_version IS
'Returns the latest approved policy version for a sub-vertical.
Use this in enrichment engine to load the active policy.';
